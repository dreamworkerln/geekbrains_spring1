Откуда взялось две иерархии параметров запроса - DTO и Entity
(зачем две, одной не хватает что-ли, наполодить классов, чтоб запутаться?)


Идея - в множестве DTO (списки заказов, кол-во доступного товара на складе и т.д.)
нужно передавать не всю сущность целиком (со всеми полями), а только ее Id.

Соответственно, на клиентской стороне удобно пользоваться запросами типа
"дай мне список, отображающий количество товара на складе, вот тебе List
id товаров, которые меня интересуют."

Но на сервере, при обработке подобного запроса, возможно,
потребуется не только id, но и другие поля товара, т.е. возможно
на серверной стороне нужно, чтобы объекты из запроса были подгружены из базы (fetched).

MapStruct позволяет в интерфейсе отображения подключать сервисы(репозитории, компоненты)
Spring, что позволяет, в свою очередь из id получить полноценные товары (со всеми полями),
используя ProductRepository
(при этом для маппинга используется не интервейс а абстрактный класс, кк остаться на интерфейсе - хз)
Соответственно код сервиса по боработке такого запроса можно будет вынести в
интерфейс маппера DTO -> Entity и не загромождать сервис.

+ Hibernate умеет кеши, поэтому, IMHO(надеюсь) если там ничего не поменялось на складе,
то запрос(преобразование productId -> Product) не пойдет в БД,
а вернентся из RAM, что обеспечит большую производительность.
(не знаю, как кеши hibernate работают)
Но вот подгружать изменяющуюся информацию, с которой надо работать в транзакции, я бы не стал.
(чтоб не продали со склада -2 товара)

Если же нет, то такое поведение (преобразование productId -> Product)
можно будет отключить.
Скорее всего так и произойдет, нужно будет прибить AbstractParam из иерархии Entity.
И пользоваться в обработчике запроса поля из AbstractParamDto.


Вот из-за этого сейчас в проекте и существует как AbstractParam так и AbstractParamDto
(две иерархии параметров запросов, DTO и Entity).
И скорее всего, после испытаний останется только одна.
